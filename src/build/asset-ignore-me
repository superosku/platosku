/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Game": () => (/* binding */ Game)
/* harmony export */ });
/* harmony import */ var heap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _GameMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _SearchPointScoreMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4);
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _worker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};







var Game = /** @class */ (function () {
    function Game(keyboardHandler, canvasWidth, canvasHeight, canvasHandler) {
        var _this = this;
        this.canvasHandler = canvasHandler;
        this.map = new _GameMap__WEBPACK_IMPORTED_MODULE_1__.GameMap(this.canvasHandler);
        var startPos = this.map.getStartCoors();
        this.player = new _Entity__WEBPACK_IMPORTED_MODULE_2__.Entity(startPos);
        this.follower = new _Entity__WEBPACK_IMPORTED_MODULE_2__.Entity(startPos);
        this.camera = new _Camera__WEBPACK_IMPORTED_MODULE_5__.Camera(canvasWidth, canvasHeight);
        this.keyboardHandler = keyboardHandler;
        this.debugPoints = [];
        this.goalX = 0;
        this.goalY = 0;
        this.debugSearchPointScores = new _SearchPointScoreMap__WEBPACK_IMPORTED_MODULE_3__.SearchPointScoreMap(this.map);
        this.frameIndex = 0;
        this.followerPath = [];
        _worker__WEBPACK_IMPORTED_MODULE_6__.worker.onmessage = function (messageEvent) {
            // console.log('worker got message', messageEvent, messageEvent.data)
            if (messageEvent.data.type === 'route-search-result') {
                _this.followerPath = messageEvent.data.payload.path;
                console.log('game: set followerPath', _this.followerPath);
            }
        };
        _worker__WEBPACK_IMPORTED_MODULE_6__.worker.onerror = function (errorEvent) {
            console.log('game: worker got error');
        };
        _worker__WEBPACK_IMPORTED_MODULE_6__.worker.onmessageerror = function (e) {
            console.log('game: worker got message error');
        };
        _worker__WEBPACK_IMPORTED_MODULE_6__.worker.postMessage({
            type: 'set-game',
            payload: {
                game: __assign(__assign({}, this), { canvasHandler: undefined, map: __assign(__assign({}, this.map), { canvasHandler: undefined }) })
            }
        });
    }
    Game.prototype.updateGoalFromMouse = function (x, y) {
        // this.goalX = x
        // this.goalY = y
    };
    Game.prototype.draw = function (ctx) {
        this.map.draw(ctx, this.camera, this.debugSearchPointScores);
        this.player.draw(ctx, this.camera);
        this.follower.draw(ctx, this.camera);
        // Draw debug points
        for (var i = 0; i < this.debugPoints.length; i++) {
            var db = this.debugPoints[i];
            // ctx.strokeStyle = 'rgba(32, 181, 39, 0.25)';
            ctx.strokeStyle = 'rgb(32, 181, 39)';
            ctx.beginPath();
            ctx.arc(this.camera.gameToScreenX(db.x + this.follower.width / 2), this.camera.gameToScreenY(db.y + this.follower.height / 2), 1, 0, 2 * Math.PI);
            ctx.stroke();
        }
        // Draw path
        if (this.followerPath.length > 3) {
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.camera.gameToScreenX(this.followerPath[0].x + this.follower.width / 2), this.camera.gameToScreenY(this.followerPath[1].y + this.follower.height / 2));
            ctx.strokeStyle = '#cd264d';
            for (var i = 1; i < this.followerPath.length; i++) {
                var db = this.followerPath[i];
                ctx.lineTo(this.camera.gameToScreenX(db.x + this.follower.width / 2), this.camera.gameToScreenY(db.y + this.follower.height / 2));
            }
            ctx.stroke();
        }
    };
    Game.prototype.update = function () {
        if (this.keyboardHandler.pressed('t')) {
            var debugPoints = this.routeSearch(this.player, 0, 0, 250, false).debugPoints;
            this.debugPoints = debugPoints;
        }
        if (this.frameIndex % (60 * 3) === 0 && this.frameIndex !== 0) {
            // const {path} = this.routeSearch(this.follower, this.player.x, this.player.y)
            // this.followerPath = path
            _worker__WEBPACK_IMPORTED_MODULE_6__.worker.postMessage({
                type: 'route-search',
                payload: {
                    entity: this.follower,
                    x: this.player.x,
                    y: this.player.y
                }
            });
        }
        if (this.followerPath.length > 0) {
            var pathItem = this.followerPath.shift();
            if (pathItem) {
                var controls = pathItem.controls;
                this.follower.updateFromControls(controls);
            }
        }
        else {
            this.follower.updateFromControls(_common__WEBPACK_IMPORTED_MODULE_4__.doNothingControls); // Do nothing
        }
        this.player.updateFromKeyboard(this.keyboardHandler);
        this.follower.update(this.map);
        this.player.update(this.map);
        this.frameIndex += 1;
        this.camera.moveTowards(this.player.x, this.player.y);
    };
    Game.prototype.routeSearch = function (entity, goalX, goalY, maxPoints, sort) {
        if (maxPoints === void 0) { maxPoints = 500; }
        if (sort === void 0) { sort = true; }
        this.map.updatePointScoreMap(this.debugSearchPointScores, Math.floor(goalX), Math.floor(goalY));
        var pointScores = this.debugSearchPointScores;
        var debugPoints = [];
        var hasher = {};
        var winner = undefined;
        var scoreEntity = function (a) {
            var center = a.entity.getCenter();
            return (0,_SearchPointScoreMap__WEBPACK_IMPORTED_MODULE_3__.getPointScore)(center, pointScores);
        };
        var compareEntity = function (a, b) {
            var scoreA = scoreEntity(a);
            var scoreB = scoreEntity(b);
            if (scoreA === scoreB) {
                return 0;
            }
            return scoreA < scoreB ? -1 : 1;
        };
        var UnsortedHeap = /** @class */ (function () {
            function UnsortedHeap() {
                this.data = [];
            }
            UnsortedHeap.prototype.push = function (item) {
                this.data.push(item);
            };
            UnsortedHeap.prototype.pop = function () {
                if (this.data.length === 0) {
                    throw "Could not pop";
                }
                return this.data.shift();
            };
            return UnsortedHeap;
        }());
        // let entities = new Heap<HandledEntity>(compareEntity);
        // let entities = new UnsortedHeap<HandledEntity>()
        var entities = sort ? new heap_js__WEBPACK_IMPORTED_MODULE_0__["default"](compareEntity) : new UnsortedHeap();
        entities.push({
            entity: entity.clone(),
            parent: undefined,
            controls: undefined
        });
        outerLoop: for (var i = 0; i < maxPoints; i++) {
            var handledEntity = entities.pop();
            if (!handledEntity) {
                break outerLoop;
            }
            for (var c = 0; c < _common__WEBPACK_IMPORTED_MODULE_4__.controlChoices.length; c++) {
                var controls = _common__WEBPACK_IMPORTED_MODULE_4__.controlChoices[c];
                var newEntity = handledEntity.entity.clone();
                var asdf = 1; //i < 10 ? 1 : 10
                for (var x = 0; x < asdf; x++) {
                    newEntity.updateFromControls(controls);
                    newEntity.update(this.map);
                }
                if (hasher[newEntity.getSearchHash()]) {
                    continue;
                }
                var newHandledEntity = {
                    entity: newEntity,
                    parent: handledEntity,
                    controls: controls,
                };
                var isSteady = (newHandledEntity.entity.isUsingLadder ||
                    newHandledEntity.entity.isOnGround ||
                    newHandledEntity.entity.isHanging);
                if (Math.floor(newEntity.x) === Math.floor(goalX) &&
                    Math.floor(newEntity.y) === Math.floor(goalY) &&
                    isSteady) {
                    winner = newHandledEntity;
                    break outerLoop;
                }
                if (!winner) {
                    winner = newHandledEntity;
                }
                if (scoreEntity(newHandledEntity) < scoreEntity(winner) &&
                    isSteady) {
                    winner = newHandledEntity;
                }
                debugPoints.push({ x: newEntity.x, y: newEntity.y });
                entities.push(newHandledEntity);
                hasher[newEntity.getSearchHash()] = true;
            }
        }
        var path = [];
        var current = winner;
        var winningControls = undefined;
        while (true) {
            if (current === undefined) {
                break;
            }
            if (current.controls) {
                winningControls = current.controls;
                path.push({
                    x: current.entity.x,
                    y: current.entity.y,
                    controls: current.controls
                });
            }
            current = current.parent;
        }
        path.reverse();
        return {
            path: path,
            debugPoints: debugPoints
        };
    };
    return Game;
}());



/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Heap": () => (/* binding */ Heap),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "toInt": () => (/* binding */ toInt)
/* harmony export */ });
var __generator = ( false) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = ( false) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = ( false) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var toInt = function (n) { return ~~n; };
/**
 * Heap
 * @type {Class}
 */
var Heap = /** @class */ (function () {
    /**
     * Heap instance constructor.
     * @param  {Function} compare Optional comparison function, defaults to Heap.minComparator<number>
     */
    function Heap(compare) {
        var _this = this;
        if (compare === void 0) { compare = Heap.minComparator; }
        this.compare = compare;
        this.heapArray = [];
        this._limit = 0;
        /**
         * Alias of add
         */
        this.offer = this.add;
        /**
         * Alias of peek
         */
        this.element = this.peek;
        /**
         * Alias of pop
         */
        this.poll = this.pop;
        /**
         * Returns the inverse to the comparison function.
         * @return {Function}
         */
        this._invertedCompare = function (a, b) {
            return -1 * _this.compare(a, b);
        };
    }
    /*
              Static methods
     */
    /**
     * Gets children indices for given index.
     * @param  {Number} idx     Parent index
     * @return {Array(Number)}  Array of children indices
     */
    Heap.getChildrenIndexOf = function (idx) {
        return [idx * 2 + 1, idx * 2 + 2];
    };
    /**
     * Gets parent index for given index.
     * @param  {Number} idx  Children index
     * @return {Number | undefined}      Parent index, -1 if idx is 0
     */
    Heap.getParentIndexOf = function (idx) {
        if (idx <= 0) {
            return -1;
        }
        var whichChildren = idx % 2 ? 1 : 2;
        return Math.floor((idx - whichChildren) / 2);
    };
    /**
     * Gets sibling index for given index.
     * @param  {Number} idx  Children index
     * @return {Number | undefined}      Sibling index, -1 if idx is 0
     */
    Heap.getSiblingIndexOf = function (idx) {
        if (idx <= 0) {
            return -1;
        }
        var whichChildren = idx % 2 ? 1 : -1;
        return idx + whichChildren;
    };
    /**
     * Min heap comparison function, default.
     * @param  {any} a     First element
     * @param  {any} b     Second element
     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up
     */
    Heap.minComparator = function (a, b) {
        if (a > b) {
            return 1;
        }
        else if (a < b) {
            return -1;
        }
        else {
            return 0;
        }
    };
    /**
     * Max heap comparison function.
     * @param  {any} a     First element
     * @param  {any} b     Second element
     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up
     */
    Heap.maxComparator = function (a, b) {
        if (b > a) {
            return 1;
        }
        else if (b < a) {
            return -1;
        }
        else {
            return 0;
        }
    };
    /**
     * Min number heap comparison function, default.
     * @param  {Number} a     First element
     * @param  {Number} b     Second element
     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up
     */
    Heap.minComparatorNumber = function (a, b) {
        return a - b;
    };
    /**
     * Max number heap comparison function.
     * @param  {Number} a     First element
     * @param  {Number} b     Second element
     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up
     */
    Heap.maxComparatorNumber = function (a, b) {
        return b - a;
    };
    /**
     * Default equality function.
     * @param  {any} a    First element
     * @param  {any} b    Second element
     * @return {Boolean}  True if equal, false otherwise
     */
    Heap.defaultIsEqual = function (a, b) {
        return a === b;
    };
    /**
     * Prints a heap.
     * @param  {Heap} heap Heap to be printed
     * @returns {String}
     */
    Heap.print = function (heap) {
        function deep(i) {
            var pi = Heap.getParentIndexOf(i);
            return Math.floor(Math.log2(pi + 1));
        }
        function repeat(str, times) {
            var out = '';
            for (; times > 0; --times) {
                out += str;
            }
            return out;
        }
        var node = 0;
        var lines = [];
        var maxLines = deep(heap.length - 1) + 2;
        var maxLength = 0;
        while (node < heap.length) {
            var i = deep(node) + 1;
            if (node === 0) {
                i = 0;
            }
            // Text representation
            var nodeText = String(heap.get(node));
            if (nodeText.length > maxLength) {
                maxLength = nodeText.length;
            }
            // Add to line
            lines[i] = lines[i] || [];
            lines[i].push(nodeText);
            node += 1;
        }
        return lines
            .map(function (line, i) {
            var times = Math.pow(2, maxLines - i) - 1;
            return (repeat(' ', Math.floor(times / 2) * maxLength) +
                line
                    .map(function (el) {
                    // centered
                    var half = (maxLength - el.length) / 2;
                    return repeat(' ', Math.ceil(half)) + el + repeat(' ', Math.floor(half));
                })
                    .join(repeat(' ', times * maxLength)));
        })
            .join('\n');
    };
    /*
              Python style
     */
    /**
     * Converts an array into an array-heap, in place
     * @param  {Array}    arr      Array to be modified
     * @param  {Function} compare  Optional compare function
     * @return {Heap}              For convenience, it returns a Heap instance
     */
    Heap.heapify = function (arr, compare) {
        var heap = new Heap(compare);
        heap.heapArray = arr;
        heap.init();
        return heap;
    };
    /**
     * Extract the peek of an array-heap
     * @param  {Array}    heapArr  Array to be modified, should be a heap
     * @param  {Function} compare  Optional compare function
     * @return {any}               Returns the extracted peek
     */
    Heap.heappop = function (heapArr, compare) {
        var heap = new Heap(compare);
        heap.heapArray = heapArr;
        return heap.pop();
    };
    /**
     * Pushes a item into an array-heap
     * @param  {Array}    heapArr  Array to be modified, should be a heap
     * @param  {any}      item     Item to push
     * @param  {Function} compare  Optional compare function
     */
    Heap.heappush = function (heapArr, item, compare) {
        var heap = new Heap(compare);
        heap.heapArray = heapArr;
        heap.push(item);
    };
    /**
     * Push followed by pop, faster
     * @param  {Array}    heapArr  Array to be modified, should be a heap
     * @param  {any}      item     Item to push
     * @param  {Function} compare  Optional compare function
     * @return {any}               Returns the extracted peek
     */
    Heap.heappushpop = function (heapArr, item, compare) {
        var heap = new Heap(compare);
        heap.heapArray = heapArr;
        return heap.pushpop(item);
    };
    /**
     * Replace peek with item
     * @param  {Array}    heapArr  Array to be modified, should be a heap
     * @param  {any}      item     Item as replacement
     * @param  {Function} compare  Optional compare function
     * @return {any}               Returns the extracted peek
     */
    Heap.heapreplace = function (heapArr, item, compare) {
        var heap = new Heap(compare);
        heap.heapArray = heapArr;
        return heap.replace(item);
    };
    /**
     * Return the `n` most valuable elements of a heap-like Array
     * @param  {Array}    heapArr  Array, should be an array-heap
     * @param  {number}   n        Max number of elements
     * @param  {Function} compare  Optional compare function
     * @return {any}               Elements
     */
    Heap.heaptop = function (heapArr, n, compare) {
        if (n === void 0) { n = 1; }
        var heap = new Heap(compare);
        heap.heapArray = heapArr;
        return heap.top(n);
    };
    /**
     * Return the `n` least valuable elements of a heap-like Array
     * @param  {Array}    heapArr  Array, should be an array-heap
     * @param  {number}   n        Max number of elements
     * @param  {Function} compare  Optional compare function
     * @return {any}               Elements
     */
    Heap.heapbottom = function (heapArr, n, compare) {
        if (n === void 0) { n = 1; }
        var heap = new Heap(compare);
        heap.heapArray = heapArr;
        return heap.bottom(n);
    };
    /**
     * Return the `n` most valuable elements of an iterable
     * @param  {number}   n        Max number of elements
     * @param  {Iterable} Iterable Iterable list of elements
     * @param  {Function} compare  Optional compare function
     * @return {any}               Elements
     */
    Heap.nlargest = function (n, iterable, compare) {
        var heap = new Heap(compare);
        heap.heapArray = __spreadArray([], __read(iterable));
        heap.init();
        return heap.top(n);
    };
    /**
     * Return the `n` least valuable elements of an iterable
     * @param  {number}   n        Max number of elements
     * @param  {Iterable} Iterable Iterable list of elements
     * @param  {Function} compare  Optional compare function
     * @return {any}               Elements
     */
    Heap.nsmallest = function (n, iterable, compare) {
        var heap = new Heap(compare);
        heap.heapArray = __spreadArray([], __read(iterable));
        heap.init();
        return heap.bottom(n);
    };
    /*
              Instance methods
     */
    /**
     * Adds an element to the heap. Aliases: `offer`.
     * Same as: push(element)
     * @param {any} element Element to be added
     * @return {Boolean} true
     */
    Heap.prototype.add = function (element) {
        this._sortNodeUp(this.heapArray.push(element) - 1);
        this._applyLimit();
        return true;
    };
    /**
     * Adds an array of elements to the heap.
     * Similar as: push(element, element, ...).
     * @param {Array} elements Elements to be added
     * @return {Boolean} true
     */
    Heap.prototype.addAll = function (elements) {
        var _a;
        var i = this.length;
        (_a = this.heapArray).push.apply(_a, __spreadArray([], __read(elements)));
        for (var l = this.length; i < l; ++i) {
            this._sortNodeUp(i);
        }
        this._applyLimit();
        return true;
    };
    /**
     * Return the bottom (lowest value) N elements of the heap.
     *
     * @param  {Number} n  Number of elements.
     * @return {Array}     Array of length <= N.
     */
    Heap.prototype.bottom = function (n) {
        if (n === void 0) { n = 1; }
        if (this.heapArray.length === 0 || n <= 0) {
            // Nothing to do
            return [];
        }
        else if (this.heapArray.length === 1) {
            // Just the peek
            return [this.heapArray[0]];
        }
        else if (n >= this.heapArray.length) {
            // The whole heap
            return __spreadArray([], __read(this.heapArray));
        }
        else {
            // Some elements
            var result = this._bottomN_push(~~n);
            return result;
        }
    };
    /**
     * Check if the heap is sorted, useful for testing purposes.
     * @return {Undefined | Element}  Returns an element if something wrong is found, otherwise it's undefined
     */
    Heap.prototype.check = function () {
        var _this = this;
        return this.heapArray.find(function (el, j) { return !!_this.getChildrenOf(j).find(function (ch) { return _this.compare(el, ch) > 0; }); });
    };
    /**
     * Remove all of the elements from this heap.
     */
    Heap.prototype.clear = function () {
        this.heapArray = [];
    };
    /**
     * Clone this heap
     * @return {Heap}
     */
    Heap.prototype.clone = function () {
        var cloned = new Heap(this.comparator());
        cloned.heapArray = this.toArray();
        cloned._limit = this._limit;
        return cloned;
    };
    /**
     * Returns the comparison function.
     * @return {Function}
     */
    Heap.prototype.comparator = function () {
        return this.compare;
    };
    /**
     * Returns true if this queue contains the specified element.
     * @param  {any}      o   Element to be found
     * @param  {Function} fn  Optional comparison function, receives (element, needle)
     * @return {Boolean}
     */
    Heap.prototype.contains = function (o, fn) {
        if (fn === void 0) { fn = Heap.defaultIsEqual; }
        return this.heapArray.findIndex(function (el) { return fn(el, o); }) >= 0;
    };
    /**
     * Initialise a heap, sorting nodes
     * @param  {Array} array Optional initial state array
     */
    Heap.prototype.init = function (array) {
        if (array) {
            this.heapArray = __spreadArray([], __read(array));
        }
        for (var i = Math.floor(this.heapArray.length); i >= 0; --i) {
            this._sortNodeDown(i);
        }
        this._applyLimit();
    };
    /**
     * Test if the heap has no elements.
     * @return {Boolean} True if no elements on the heap
     */
    Heap.prototype.isEmpty = function () {
        return this.length === 0;
    };
    /**
     * Get the leafs of the tree (no children nodes)
     */
    Heap.prototype.leafs = function () {
        if (this.heapArray.length === 0) {
            return [];
        }
        var pi = Heap.getParentIndexOf(this.heapArray.length - 1);
        return this.heapArray.slice(pi + 1);
    };
    Object.defineProperty(Heap.prototype, "length", {
        /**
         * Length of the heap.
         * @return {Number}
         */
        get: function () {
            return this.heapArray.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Heap.prototype, "limit", {
        /**
         * Get length limit of the heap.
         * @return {Number}
         */
        get: function () {
            return this._limit;
        },
        /**
         * Set length limit of the heap.
         * @return {Number}
         */
        set: function (_l) {
            this._limit = ~~_l;
            this._applyLimit();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Top node. Aliases: `element`.
     * Same as: `top(1)[0]`
     * @return {any} Top node
     */
    Heap.prototype.peek = function () {
        return this.heapArray[0];
    };
    /**
     * Extract the top node (root). Aliases: `poll`.
     * @return {any} Extracted top node, undefined if empty
     */
    Heap.prototype.pop = function () {
        var last = this.heapArray.pop();
        if (this.length > 0 && last !== undefined) {
            return this.replace(last);
        }
        return last;
    };
    /**
     * Pushes element(s) to the heap.
     * @param  {...any} elements Elements to insert
     * @return {Boolean} True if elements are present
     */
    Heap.prototype.push = function () {
        var elements = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elements[_i] = arguments[_i];
        }
        if (elements.length < 1) {
            return false;
        }
        else if (elements.length === 1) {
            return this.add(elements[0]);
        }
        else {
            return this.addAll(elements);
        }
    };
    /**
     * Same as push & pop in sequence, but faster
     * @param  {any} element Element to insert
     * @return {any}  Extracted top node
     */
    Heap.prototype.pushpop = function (element) {
        var _a;
        if (this.compare(this.heapArray[0], element) < 0) {
            _a = __read([this.heapArray[0], element], 2), element = _a[0], this.heapArray[0] = _a[1];
            this._sortNodeDown(0);
        }
        return element;
    };
    /**
     * Remove an element from the heap.
     * @param  {any}   o      Element to be found
     * @param  {Function} fn  Optional function to compare
     * @return {Boolean}      True if the heap was modified
     */
    Heap.prototype.remove = function (o, fn) {
        if (fn === void 0) { fn = Heap.defaultIsEqual; }
        if (this.length > 0) {
            if (o === undefined) {
                this.pop();
                return true;
            }
            else {
                var idx = this.heapArray.findIndex(function (el) { return fn(el, o); });
                if (idx >= 0) {
                    if (idx === 0) {
                        this.pop();
                    }
                    else if (idx === this.length - 1) {
                        this.heapArray.pop();
                    }
                    else {
                        this.heapArray.splice(idx, 1, this.heapArray.pop());
                        this._sortNodeUp(idx);
                        this._sortNodeDown(idx);
                    }
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Pop the current peek value, and add the new item.
     * @param  {any} element  Element to replace peek
     * @return {any}         Old peek
     */
    Heap.prototype.replace = function (element) {
        var peek = this.heapArray[0];
        this.heapArray[0] = element;
        this._sortNodeDown(0);
        return peek;
    };
    /**
     * Size of the heap
     * @return {Number}
     */
    Heap.prototype.size = function () {
        return this.length;
    };
    /**
     * Return the top (highest value) N elements of the heap.
     *
     * @param  {Number} n  Number of elements.
     * @return {Array}    Array of length <= N.
     */
    Heap.prototype.top = function (n) {
        if (n === void 0) { n = 1; }
        if (this.heapArray.length === 0 || n <= 0) {
            // Nothing to do
            return [];
        }
        else if (this.heapArray.length === 1 || n === 1) {
            // Just the peek
            return [this.heapArray[0]];
        }
        else if (n >= this.heapArray.length) {
            // The whole peek
            return __spreadArray([], __read(this.heapArray));
        }
        else {
            // Some elements
            var result = this._topN_push(~~n);
            return result;
        }
    };
    /**
     * Clone the heap's internal array
     * @return {Array}
     */
    Heap.prototype.toArray = function () {
        return __spreadArray([], __read(this.heapArray));
    };
    /**
     * String output, call to Array.prototype.toString()
     * @return {String}
     */
    Heap.prototype.toString = function () {
        return this.heapArray.toString();
    };
    /**
     * Get the element at the given index.
     * @param  {Number} i Index to get
     * @return {any}       Element at that index
     */
    Heap.prototype.get = function (i) {
        return this.heapArray[i];
    };
    /**
     * Get the elements of these node's children
     * @param  {Number} idx Node index
     * @return {Array(any)}  Children elements
     */
    Heap.prototype.getChildrenOf = function (idx) {
        var _this = this;
        return Heap.getChildrenIndexOf(idx)
            .map(function (i) { return _this.heapArray[i]; })
            .filter(function (e) { return e !== undefined; });
    };
    /**
     * Get the element of this node's parent
     * @param  {Number} idx Node index
     * @return {any}     Parent element
     */
    Heap.prototype.getParentOf = function (idx) {
        var pi = Heap.getParentIndexOf(idx);
        return this.heapArray[pi];
    };
    /**
     * Iterator interface
     */
    Heap.prototype[Symbol.iterator] = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!this.length) return [3 /*break*/, 2];
                    return [4 /*yield*/, this.pop()];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 0];
                case 2: return [2 /*return*/];
            }
        });
    };
    /**
     * Returns an iterator. To comply with Java interface.
     */
    Heap.prototype.iterator = function () {
        return this;
    };
    /**
     * Limit heap size if needed
     */
    Heap.prototype._applyLimit = function () {
        if (this._limit && this._limit < this.heapArray.length) {
            var rm = this.heapArray.length - this._limit;
            // It's much faster than splice
            while (rm) {
                this.heapArray.pop();
                --rm;
            }
        }
    };
    /**
     * Return the bottom (lowest value) N elements of the heap, without corner cases, unsorted
     *
     * @param  {Number} n  Number of elements.
     * @return {Array}     Array of length <= N.
     */
    Heap.prototype._bottomN_push = function (n) {
        // Use an inverted heap
        var bottomHeap = new Heap(this.compare);
        bottomHeap.limit = n;
        bottomHeap.heapArray = this.heapArray.slice(-n);
        bottomHeap.init();
        var startAt = this.heapArray.length - 1 - n;
        var parentStartAt = Heap.getParentIndexOf(startAt);
        var indices = [];
        for (var i = startAt; i > parentStartAt; --i) {
            indices.push(i);
        }
        var arr = this.heapArray;
        while (indices.length) {
            var i = indices.shift();
            if (this.compare(arr[i], bottomHeap.peek()) > 0) {
                bottomHeap.replace(arr[i]);
                if (i % 2) {
                    indices.push(Heap.getParentIndexOf(i));
                }
            }
        }
        return bottomHeap.toArray();
    };
    /**
     * Move a node to a new index, switching places
     * @param  {Number} j First node index
     * @param  {Number} k Another node index
     */
    Heap.prototype._moveNode = function (j, k) {
        var _a;
        _a = __read([this.heapArray[k], this.heapArray[j]], 2), this.heapArray[j] = _a[0], this.heapArray[k] = _a[1];
    };
    /**
     * Move a node down the tree (to the leaves) to find a place where the heap is sorted.
     * @param  {Number} i Index of the node
     */
    Heap.prototype._sortNodeDown = function (i) {
        var _this = this;
        var moveIt = i < this.heapArray.length - 1;
        var self = this.heapArray[i];
        var getPotentialParent = function (best, j) {
            if (_this.heapArray.length > j && _this.compare(_this.heapArray[j], _this.heapArray[best]) < 0) {
                best = j;
            }
            return best;
        };
        while (moveIt) {
            var childrenIdx = Heap.getChildrenIndexOf(i);
            var bestChildIndex = childrenIdx.reduce(getPotentialParent, childrenIdx[0]);
            var bestChild = this.heapArray[bestChildIndex];
            if (typeof bestChild !== 'undefined' && this.compare(self, bestChild) > 0) {
                this._moveNode(i, bestChildIndex);
                i = bestChildIndex;
            }
            else {
                moveIt = false;
            }
        }
    };
    /**
     * Move a node up the tree (to the root) to find a place where the heap is sorted.
     * @param  {Number} i Index of the node
     */
    Heap.prototype._sortNodeUp = function (i) {
        var moveIt = i > 0;
        while (moveIt) {
            var pi = Heap.getParentIndexOf(i);
            if (pi >= 0 && this.compare(this.heapArray[pi], this.heapArray[i]) > 0) {
                this._moveNode(i, pi);
                i = pi;
            }
            else {
                moveIt = false;
            }
        }
    };
    /**
     * Return the top (highest value) N elements of the heap, without corner cases, unsorted
     * Implementation: push.
     *
     * @param  {Number} n  Number of elements.
     * @return {Array}     Array of length <= N.
     */
    Heap.prototype._topN_push = function (n) {
        // Use an inverted heap
        var topHeap = new Heap(this._invertedCompare);
        topHeap.limit = n;
        var indices = [0];
        var arr = this.heapArray;
        while (indices.length) {
            var i = indices.shift();
            if (i < arr.length) {
                if (topHeap.length < n) {
                    topHeap.push(arr[i]);
                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i))));
                }
                else if (this.compare(arr[i], topHeap.peek()) < 0) {
                    topHeap.replace(arr[i]);
                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i))));
                }
            }
        }
        return topHeap.toArray();
    };
    /**
     * Return the top (highest value) N elements of the heap, without corner cases, unsorted
     * Implementation: init + push.
     *
     * @param  {Number} n  Number of elements.
     * @return {Array}     Array of length <= N.
     */
    Heap.prototype._topN_fill = function (n) {
        // Use an inverted heap
        var heapArray = this.heapArray;
        var topHeap = new Heap(this._invertedCompare);
        topHeap.limit = n;
        topHeap.heapArray = heapArray.slice(0, n);
        topHeap.init();
        var branch = Heap.getParentIndexOf(n - 1) + 1;
        var indices = [];
        for (var i = branch; i < n; ++i) {
            indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i).filter(function (l) { return l < heapArray.length; }))));
        }
        if ((n - 1) % 2) {
            indices.push(n);
        }
        while (indices.length) {
            var i = indices.shift();
            if (i < heapArray.length) {
                if (this.compare(heapArray[i], topHeap.peek()) < 0) {
                    topHeap.replace(heapArray[i]);
                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i))));
                }
            }
        }
        return topHeap.toArray();
    };
    /**
     * Return the top (highest value) N elements of the heap, without corner cases, unsorted
     * Implementation: heap.
     *
     * @param  {Number} n  Number of elements.
     * @return {Array}     Array of length <= N.
     */
    Heap.prototype._topN_heap = function (n) {
        var topHeap = this.clone();
        var result = [];
        for (var i = 0; i < n; ++i) {
            result.push(topHeap.pop());
        }
        return result;
    };
    /**
     * Return index of the top element
     * @param list
     */
    Heap.prototype._topIdxOf = function (list) {
        if (!list.length) {
            return -1;
        }
        var idx = 0;
        var top = list[idx];
        for (var i = 1; i < list.length; ++i) {
            var comp = this.compare(list[i], top);
            if (comp < 0) {
                idx = i;
                top = list[i];
            }
        }
        return idx;
    };
    /**
     * Return the top element
     * @param list
     */
    Heap.prototype._topOf = function () {
        var list = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            list[_i] = arguments[_i];
        }
        var heap = new Heap(this.compare);
        heap.init(list);
        return heap.peek();
    };
    return Heap;
}());

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Heap);



/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GameMap": () => (/* binding */ GameMap)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _levels__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _levels_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var levelData = _levels_json__WEBPACK_IMPORTED_MODULE_2__;
var GameMap = /** @class */ (function () {
    function GameMap(canvasHandler) {
        var _this = this;
        this.canvasHandler = canvasHandler;
        var randomMap = (0,_levels__WEBPACK_IMPORTED_MODULE_1__.getRandomMap)(levelData);
        this.height = _common__WEBPACK_IMPORTED_MODULE_0__.levelHeight * _common__WEBPACK_IMPORTED_MODULE_0__.mapHeight;
        this.width = _common__WEBPACK_IMPORTED_MODULE_0__.levelWidth * _common__WEBPACK_IMPORTED_MODULE_0__.mapWidth;
        this.data = (0,_common__WEBPACK_IMPORTED_MODULE_0__.range)(this.width).map(function (x) { return (0,_common__WEBPACK_IMPORTED_MODULE_0__.range)(_this.height).map(function (y) {
            return 0;
        }); });
        for (var xx = 0; xx < _common__WEBPACK_IMPORTED_MODULE_0__.mapWidth; xx++) {
            for (var yy = 0; yy < _common__WEBPACK_IMPORTED_MODULE_0__.mapHeight; yy++) {
                for (var x = 0; x < _common__WEBPACK_IMPORTED_MODULE_0__.levelWidth; x++) {
                    for (var y = 0; y < _common__WEBPACK_IMPORTED_MODULE_0__.levelHeight; y++) {
                        var outputX = x + xx * _common__WEBPACK_IMPORTED_MODULE_0__.levelWidth;
                        var outputY = y + yy * _common__WEBPACK_IMPORTED_MODULE_0__.levelHeight;
                        var level = randomMap.levels[xx][yy];
                        this.data[outputX][outputY] = level.data[x][y];
                    }
                }
            }
        }
    }
    GameMap.prototype.getStartCoors = function () {
        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.width; y++) {
                if (this.at(x, y) === 3) {
                    return { x: x, y: y };
                }
            }
        }
        return { x: 2, y: 2 };
    };
    GameMap.prototype.updatePointScoreMap = function (pointScores, goalX, goalY) {
        pointScores.reset();
        var queue = [{ x: goalX, y: goalY, score: 1, sinceGround: 0 }];
        var i = 0;
        while (queue) {
            i++;
            if (i > 1000) {
                return pointScores;
            }
            var point = queue.shift();
            if (!point) {
                break;
            }
            if (pointScores.has(point.x, point.y)) {
                continue;
            }
            pointScores.set(point.x, point.y, point.score);
            var neighbours = [
                { x: point.x + 1, y: point.y },
                { x: point.x - 1, y: point.y },
                { x: point.x, y: point.y - 1 },
                { x: point.x, y: point.y + 1 },
            ];
            for (var i_1 = 0; i_1 < neighbours.length; i_1++) {
                var n = neighbours[i_1];
                // const isMovingDown = point.y - n.y < 0
                // let sinceGround = point.sinceGround + (isMovingDown ? 1 : 1)
                // let sinceGround = point.sinceGround + 1
                var sinceGround = 0;
                if (this.at(n.x, n.y + 1) !== 0
                // this.at(point.x, point.y + 1) !== 0
                ) {
                    sinceGround = 0;
                }
                // Too long since touching ground
                if (sinceGround > 3) {
                    continue;
                }
                // Point already handled
                if (pointScores.has(n.x, n.y)) {
                    continue;
                }
                // Not moveable tile
                if (this.at(n.x, n.y) === 1) {
                    continue;
                }
                queue.push(__assign(__assign({}, n), { score: point.score + 1, sinceGround: sinceGround }));
            }
        }
        //
        // if (Object.keys(pointScores).length > 3) {
        //   debugger;
        // }
        // return pointScores
    };
    GameMap.prototype.draw = function (ctx, camera, debugPointScores) {
        var boundaries = camera.getDrawBoundaries();
        var startDrawX = camera.gameToScreenX(0);
        var startDrawY = camera.gameToScreenY(0);
        for (var x = Math.max(0, boundaries.topLeftX); x < Math.min(boundaries.bottomRightX, this.width); x++) {
            for (var y = Math.max(0, boundaries.topLeftY); y < Math.min(boundaries.bottomRightY, this.height); y++) {
                ctx.fillStyle = '#1a1c1d';
                if (this.data[x][y] === 1) {
                    ctx.fillStyle = '#8a8a8a';
                }
                if (this.data[x][y] === 3) {
                    ctx.fillStyle = '#62b52b';
                }
                if (this.data[x][y] === 4) {
                    ctx.fillStyle = '#b34949';
                }
                // if (debugPointScores && this.at(x, y) !== 1) {
                //   const ps = debugPointScores.get(x, y)
                //   if (ps !== undefined) {
                //     const score = 255 - Math.min(255, Math.max(0, Math.floor(ps * 10 + 128)))
                //     ctx.fillStyle = `rgb(${score}, ${score}, ${score})`
                //   }
                // }
                ctx.fillRect(startDrawX + _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * x, startDrawY + _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * y, _common__WEBPACK_IMPORTED_MODULE_0__.tileSize, _common__WEBPACK_IMPORTED_MODULE_0__.tileSize);
                if (this.data[x][y] === 0) {
                    this.canvasHandler.drawKeyTo(ctx, 'background', 'regular', startDrawX + _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * x, startDrawY + _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * y);
                }
                if (this.data[x][y] === 2) {
                    this.canvasHandler.drawKeyTo(ctx, 'background', 'ladder', startDrawX + _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * x, startDrawY + _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * y);
                }
                if (this.data[x][y] === 5) {
                    this.canvasHandler.drawKeyTo(ctx, 'background', 'platform-ladder', startDrawX + _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * x, startDrawY + _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * y);
                }
                if (this.data[x][y] === 6) {
                    this.canvasHandler.drawKeyTo(ctx, 'background', 'platform', startDrawX + _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * x, startDrawY + _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * y);
                }
                // Tiled ground
                if (this.data[x][y] === 1 || this.data[x][y] === 7) {
                    var expected = this.data[x][y];
                    var canvasMapKey = ((this.at(x, y - 1) === expected ? '#' : '_') +
                        (this.at(x - 1, y) === expected ? '#' : '_') +
                        (this.at(x + 1, y) === expected ? '#' : '_') +
                        (this.at(x, y + 1) === expected ? '#' : '_'));
                    this.canvasHandler.drawKeyTo(ctx, this.data[x][y] === 1 ? 'ground' : 'wood', canvasMapKey, startDrawX + _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * x, startDrawY + _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * y);
                }
            }
        }
        /*
        if (!debugPointScores) {
          return
        }
    
        const res = 8
        for (let xx = 0; xx < this.width * res; xx++) {
          for (let yy = 0; yy < this.height * res; yy++) {
            const x = xx / res
            const y = yy / res
    
            if (this.at(x, y) !== 0) {
              continue
            }
    
            const score = 255 - Math.min(255, Math.max(0, Math.floor(
              getPointScore({x: x, y: y}, debugPointScores) * 20
            )))
            ctx.fillStyle = `rgb(${score}, ${0}, ${0})`
    
            ctx.fillRect(x * tileSize, y * tileSize, tileSize / res, tileSize / res);
          }
        }
         */
    };
    GameMap.prototype.at = function (fx, fy) {
        var x = Math.floor(fx);
        var y = Math.floor(fy);
        if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
            return 1;
        }
        return this.data[x][y];
    };
    GameMap.prototype.blockedAt = function (fx, fy) {
        var val = this.at(fx, fy);
        return val === 1 || val === 7;
    };
    return GameMap;
}());



/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "controlChoices": () => (/* binding */ controlChoices),
/* harmony export */   "doNothingControls": () => (/* binding */ doNothingControls),
/* harmony export */   "levelHeight": () => (/* binding */ levelHeight),
/* harmony export */   "levelWidth": () => (/* binding */ levelWidth),
/* harmony export */   "mapHeight": () => (/* binding */ mapHeight),
/* harmony export */   "mapWidth": () => (/* binding */ mapWidth),
/* harmony export */   "pow2": () => (/* binding */ pow2),
/* harmony export */   "range": () => (/* binding */ range),
/* harmony export */   "tileSize": () => (/* binding */ tileSize)
/* harmony export */ });
var tileSize = 24 * 3;
// For a single map tile
var levelHeight = 8;
var levelWidth = 12;
// how many map tiles
var mapWidth = 5;
var mapHeight = 4;
var range = function (n) {
    var l = [];
    for (var i = 0; i < n; i++) {
        l.push(i);
    }
    return l;
};
var pow2 = function (n) {
    return n * n;
};
var doNothingControls = { left: false, right: false, down: false, up: false, jump: false };
var controlChoices = [
    { left: false, right: false, down: false, up: true, jump: false },
    { left: false, right: false, down: true, up: false, jump: false },
    doNothingControls,
    { left: true, right: false, down: false, up: false, jump: false },
    { left: false, right: true, down: false, up: false, jump: false },
    { left: false, right: false, down: false, up: false, jump: true },
    { left: true, right: false, down: false, up: false, jump: true },
    { left: false, right: true, down: false, up: false, jump: true },
    { left: false, right: true, down: true, up: false, jump: true }, // Croutch down
];


/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getRandomMap": () => (/* binding */ getRandomMap)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var getRandomRoute = function () {
    var start = { x: Math.floor(Math.random() * _common__WEBPACK_IMPORTED_MODULE_0__.mapWidth), y: 0 };
    var end = { x: Math.floor(Math.random() * _common__WEBPACK_IMPORTED_MODULE_0__.mapWidth), y: _common__WEBPACK_IMPORTED_MODULE_0__.mapHeight - 1 };
    var getRandomDirection = function (point) {
        if (point.x === 0) {
            return 'right';
        }
        if (point.x === _common__WEBPACK_IMPORTED_MODULE_0__.mapWidth - 1) {
            return 'left';
        }
        if (Math.random() < 0.5) {
            return 'left';
        }
        return 'right';
    };
    var route = [start];
    var direction = getRandomDirection(start);
    for (var i = 0; i < 80; i++) {
        var currentPoint = route[route.length - 1];
        var newPoint = __assign({}, currentPoint);
        var isLastRow = currentPoint.y === _common__WEBPACK_IMPORTED_MODULE_0__.mapHeight - 1;
        var goDown = Math.random() < 0.5;
        if (isLastRow) {
            var dir = Math.max(-1, Math.min(1, currentPoint.x - end.x));
            if (dir === 0) {
                break;
            }
            newPoint = { x: currentPoint.x - dir, y: currentPoint.y };
        }
        else if (goDown) {
            newPoint = { x: currentPoint.x, y: currentPoint.y + 1 };
            direction = getRandomDirection(newPoint);
        }
        else if (direction === 'left') {
            if (currentPoint.x === 0) {
                newPoint = { x: currentPoint.x, y: currentPoint.y + 1 };
                direction = getRandomDirection(newPoint);
            }
            else {
                newPoint = { x: currentPoint.x - 1, y: currentPoint.y };
            }
        }
        else if (direction === 'right') {
            if (currentPoint.x === _common__WEBPACK_IMPORTED_MODULE_0__.mapWidth - 1) {
                newPoint = { x: currentPoint.x, y: currentPoint.y + 1 };
                direction = getRandomDirection(newPoint);
            }
            else {
                newPoint = { x: currentPoint.x + 1, y: currentPoint.y };
            }
        }
        route.push(newPoint);
        if (newPoint.x === end.x && newPoint.y === end.y) {
            break;
        }
    }
    return route;
};
var getRandomMap = function (levelData) {
    console.log('getRandomMap');
    var levels = [];
    var route = getRandomRoute();
    var _loop_1 = function (x) {
        var col = [];
        levels.push(col);
        var _loop_2 = function (y) {
            var routeIndex = route.findIndex(function (p) { return p.x === x && p.y === y; });
            var previousRouteIndex = routeIndex > 0 ? routeIndex - 1 : undefined;
            var nextRouteIndex = routeIndex < route.length - 1 ? routeIndex + 1 : undefined;
            var nextMapper = {};
            nextMapper[1] = 'left';
            nextMapper[-1] = 'right';
            nextMapper[0] = 'down';
            var prevMapper = {};
            prevMapper[1] = 'left';
            prevMapper[-1] = 'right';
            prevMapper[0] = 'top';
            var previousDir = previousRouteIndex !== undefined ? (prevMapper[x - route[previousRouteIndex].x]) : undefined;
            var nextDir = nextRouteIndex !== undefined ? (nextMapper[x - route[nextRouteIndex].x]) : undefined;
            if (routeIndex > 0 && y < 3 && (!previousDir || !nextDir)) {
                debugger;
            }
            var possibleLevels = levelData.levels.filter(function (level, i) {
                // Skip first debug level
                if (i === 0) {
                    return false;
                }
                // If start of the route, must have start door, otherwise cant have start door
                var isStartDoor = level.tags.indexOf('start-door') >= 0;
                if (routeIndex === 0) {
                    return isStartDoor;
                }
                else if (isStartDoor) {
                    return false;
                }
                // If end of the route, must have end door, otherwise cant have end door
                var isEndDoor = level.tags.indexOf('end-door') >= 0;
                if (routeIndex > 0 && nextDir === undefined) {
                    return isEndDoor;
                }
                else if (isEndDoor) {
                    return false;
                }
                // Must follow route
                if (routeIndex >= 0 &&
                    ((previousDir && previousDir === 'top' && level.topType === 'blocked') ||
                        (previousDir && previousDir === 'left' && level.leftType === 'blocked') ||
                        (previousDir && previousDir === 'right' && level.rightType === 'blocked') ||
                        (nextDir && nextDir === 'down' && level.bottomType === 'blocked') ||
                        (nextDir && nextDir === 'left' && level.leftType === 'blocked') ||
                        (nextDir && nextDir === 'right' && level.rightType === 'blocked'))) {
                    return false;
                }
                // Map corners must be blocked
                if ((x === 0 && level.leftType !== 'blocked') ||
                    (y === 0 && level.topType !== 'blocked') ||
                    (y === _common__WEBPACK_IMPORTED_MODULE_0__.mapHeight - 1 && level.bottomType !== 'blocked') ||
                    (x === _common__WEBPACK_IMPORTED_MODULE_0__.mapWidth - 1 && level.rightType !== 'blocked')) {
                    return false;
                }
                // Must match surrounding types
                var leftLevel = x > 0 ? levels[x - 1][y] : undefined;
                var topLevel = y > 0 ? levels[x][y - 1] : undefined;
                if ((leftLevel && leftLevel.rightType !== level.leftType) ||
                    (topLevel && topLevel.bottomType !== level.topType)) {
                    return false;
                }
                return true;
            });
            if (possibleLevels.length === 0) {
                console.log(previousDir, nextDir);
                possibleLevels = [levelData.levels[0]];
            }
            var index = Math.floor(Math.random() * possibleLevels.length);
            var randomLevel = possibleLevels[index];
            col.push(randomLevel);
        };
        for (var y = 0; y < _common__WEBPACK_IMPORTED_MODULE_0__.mapHeight; y++) {
            _loop_2(y);
        }
    };
    for (var x = 0; x < _common__WEBPACK_IMPORTED_MODULE_0__.mapWidth; x++) {
        _loop_1(x);
    }
    return {
        levels: levels,
        route: route,
    };
};


/***/ }),
/* 6 */
/***/ ((module) => {

module.exports = JSON.parse('{"levels":[{"data":[[1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,1],[1,1,0,0,0,0,1,1],[1,0,1,0,0,1,0,1],[1,0,0,1,1,0,0,1],[1,0,0,1,1,0,0,1],[1,0,1,0,0,1,0,1],[1,1,0,0,0,0,1,1],[1,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1]],"leftType":"blocked","rightType":"blocked","topType":"open","bottomType":"blocked","tags":[]},{"data":[[1,1,1,1,0,0,1,1],[1,7,7,7,0,0,1,1],[1,7,0,0,0,0,0,1],[7,7,0,5,2,2,2,1],[7,0,0,6,0,0,0,1],[7,0,0,6,0,0,0,1],[7,0,0,5,2,2,1,1],[7,7,0,1,0,0,1,1],[1,7,7,7,0,0,5,1],[1,0,1,1,1,1,0,1],[1,0,5,2,2,2,2,1],[1,1,1,1,1,1,1,1]],"leftType":"open","rightType":"blocked","topType":"blocked","bottomType":"blocked","tags":[]},{"data":[[1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,1],[1,0,0,5,2,2,2,1],[1,0,0,1,1,1,1,1],[1,0,0,5,2,2,1,1],[1,0,0,6,0,0,1,1],[1,1,0,6,0,0,1,1],[1,0,0,1,0,0,0,1],[1,0,0,1,0,0,0,1],[1,0,0,1,0,0,0,1],[1,0,0,1,0,0,0,1],[1,1,0,0,0,0,1,1]],"leftType":"blocked","rightType":"open","topType":"blocked","bottomType":"blocked","tags":[]},{"data":[[1,1,1,1,1,1,1,1],[1,0,0,5,2,2,2,1],[1,0,0,1,1,1,0,1],[1,0,0,1,0,0,0,1],[1,1,1,1,0,1,1,1],[1,0,0,0,0,1,0,5],[1,0,0,1,1,1,0,6],[1,0,0,1,0,0,0,1],[1,0,0,1,0,0,0,1],[1,0,0,5,2,2,2,1],[1,0,0,6,0,0,0,1],[1,1,1,1,1,1,1,1]],"leftType":"blocked","rightType":"blocked","topType":"blocked","bottomType":"open","tags":[]},{"data":[[1,1,1,0,0,0,0,1],[1,0,1,0,1,1,0,1],[1,0,1,0,1,1,0,1],[1,0,1,0,1,1,0,1],[1,0,5,2,5,2,2,1],[1,0,6,0,1,0,0,1],[1,0,6,0,1,0,0,1],[1,0,6,0,0,0,0,1],[1,0,1,1,0,0,0,1],[1,0,1,1,0,0,1,1],[1,0,0,0,0,1,1,1],[1,1,1,0,0,1,1,1]],"leftType":"open","rightType":"open","topType":"blocked","bottomType":"blocked","tags":[]},{"data":[[1,1,1,1,1,1,1,1],[1,0,5,2,1,0,1,1],[1,0,1,0,1,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[2,2,2,1,0,0,5,2],[1,0,0,1,0,0,0,0],[1,0,0,1,0,0,0,1],[1,0,0,5,2,2,2,1],[1,0,0,6,0,0,0,1],[1,0,0,6,0,0,0,1],[1,1,1,1,1,1,1,1]],"leftType":"blocked","rightType":"blocked","topType":"open","bottomType":"open","tags":[]},{"data":[[1,1,1,0,5,2,2,1],[1,0,1,0,1,0,0,1],[1,0,1,0,1,0,0,1],[1,0,6,0,1,0,0,1],[1,0,6,0,0,0,1,1],[2,2,5,2,2,2,1,1],[0,0,0,0,0,0,1,1],[1,1,1,1,1,0,1,1],[1,0,5,2,2,2,1,1],[1,0,1,1,1,1,1,1],[1,0,2,2,2,2,2,1],[1,1,1,1,1,1,1,1]],"leftType":"open","rightType":"blocked","topType":"open","bottomType":"blocked","tags":[]},{"data":[[1,1,1,1,1,1,1,1],[1,0,0,5,2,2,1,1],[1,0,0,7,0,0,1,1],[6,0,0,7,0,0,0,1],[6,0,0,7,0,0,0,1],[5,2,2,7,0,0,1,1],[6,0,0,0,0,0,1,1],[1,0,0,0,7,7,7,1],[1,0,5,2,7,7,7,1],[1,0,1,0,5,6,0,1],[1,0,1,0,0,6,0,1],[1,1,1,0,0,1,1,1]],"leftType":"blocked","rightType":"open","topType":"open","bottomType":"blocked","tags":[]},{"data":[[1,1,1,1,1,1,1,1],[1,0,5,2,5,2,2,1],[1,0,1,0,1,1,0,1],[1,0,1,0,1,1,0,1],[1,0,1,0,0,1,0,1],[1,0,1,0,0,5,2,5],[1,0,1,0,0,6,0,0],[1,0,5,2,2,5,2,1],[1,0,6,0,0,6,0,1],[1,0,6,0,0,6,0,1],[1,0,5,2,2,1,1,1],[1,1,1,0,0,1,1,1]],"leftType":"blocked","rightType":"open","topType":"blocked","bottomType":"open","tags":[]},{"data":[[1,1,1,0,0,1,1,1],[1,0,5,2,2,1,1,1],[1,0,1,0,0,0,1,1],[1,0,1,0,0,0,0,1],[1,0,1,0,0,0,0,1],[1,0,0,5,2,1,0,5],[1,0,0,1,0,1,0,6],[1,0,0,1,0,1,0,6],[1,0,0,1,0,5,2,6],[1,0,0,0,0,0,0,1],[1,0,1,1,0,1,1,1],[1,1,1,1,1,1,1,1]],"leftType":"open","rightType":"blocked","topType":"blocked","bottomType":"open","tags":[]},{"data":[[1,1,1,1,1,1,1,1],[1,0,6,0,0,0,0,1],[1,0,5,2,2,2,2,1],[1,0,7,7,7,7,0,1],[1,0,7,0,7,7,0,1],[2,2,7,0,6,0,0,1],[0,0,7,0,5,2,2,1],[0,0,7,0,7,0,0,1],[0,0,7,0,7,7,7,1],[1,0,5,2,2,2,2,1],[1,0,6,0,0,0,0,1],[1,1,1,1,1,1,1,1]],"leftType":"blocked","rightType":"blocked","topType":"open","bottomType":"blocked","tags":[]},{"data":[[0,0,0,0,0,0,1,1],[0,0,0,0,5,2,2,1],[0,0,6,0,1,0,0,1],[0,0,5,2,1,0,0,1],[0,0,1,0,6,0,0,1],[2,2,1,0,5,2,2,1],[0,0,1,0,1,1,0,1],[1,0,1,0,1,1,0,1],[1,0,1,0,5,2,2,1],[1,0,1,0,6,0,0,1],[1,0,1,0,1,0,0,1],[1,1,1,0,0,0,0,1]],"leftType":"open","rightType":"open","topType":"open","bottomType":"blocked","tags":[]},{"data":[[1,1,1,1,7,7,7,7],[1,0,1,0,7,7,7,7],[1,0,1,0,5,2,2,7],[0,0,1,0,1,0,0,7],[0,0,6,0,1,0,0,7],[2,2,5,2,1,0,0,5],[0,0,6,0,1,0,0,1],[0,0,1,0,1,0,0,1],[0,0,1,0,6,0,0,6],[1,0,1,0,1,0,0,6],[1,0,1,0,5,2,2,1],[1,1,1,0,0,0,0,1]],"leftType":"blocked","rightType":"open","topType":"open","bottomType":"open","tags":[]},{"data":[[1,1,1,0,0,0,0,1],[1,0,5,2,7,7,0,1],[1,0,7,0,7,7,0,1],[1,0,7,0,7,7,0,1],[1,0,0,0,0,0,0,1],[1,0,0,5,2,2,2,5],[1,0,0,7,0,0,0,0],[1,0,0,7,0,0,0,1],[1,0,0,7,0,0,0,1],[1,0,0,0,0,0,0,1],[1,0,0,0,5,2,2,1],[1,0,0,0,1,1,1,1]],"leftType":"open","rightType":"open","topType":"blocked","bottomType":"open","tags":[]},{"data":[[1,0,0,1,0,0,1,1],[1,0,0,1,0,0,1,1],[0,0,0,1,0,0,0,0],[0,0,0,5,2,2,2,1],[0,0,0,7,7,0,0,1],[2,2,2,7,7,0,0,5],[0,0,0,0,7,0,0,0],[1,0,0,0,7,0,0,1],[1,0,0,7,7,0,0,1],[0,0,0,7,7,0,0,1],[0,0,0,2,2,2,2,1],[1,1,1,1,1,1,1,1]],"leftType":"open","rightType":"blocked","topType":"open","bottomType":"open","tags":[]},{"data":[[1,1,1,1,1,1,1,1],[1,0,5,2,2,2,2,1],[1,0,7,7,7,7,0,1],[1,0,7,0,0,7,0,1],[1,0,0,0,0,6,0,1],[1,0,0,0,0,6,0,1],[1,0,0,0,0,6,0,1],[1,0,5,2,2,7,0,1],[1,0,7,7,7,7,0,1],[1,0,0,1,1,1,0,1],[1,0,0,0,1,1,0,1],[1,0,0,0,0,1,1,1]],"leftType":"blocked","rightType":"open","topType":"blocked","bottomType":"blocked","tags":[]},{"data":[[0,1,0,0,0,1,0,0],[0,5,2,1,0,5,2,1],[0,1,0,5,2,1,0,0],[0,5,2,1,0,5,2,1],[0,1,0,5,2,1,0,1],[2,1,0,1,0,0,0,5],[0,0,0,1,0,0,0,0],[0,1,0,5,2,1,0,0],[0,5,2,1,0,5,2,1],[0,1,0,5,2,1,0,0],[0,5,2,1,0,5,2,1],[0,1,0,0,0,1,0,0]],"leftType":"open","rightType":"open","topType":"open","bottomType":"open","tags":[]},{"data":[[0,0,1,0,0,0,0,1],[0,0,1,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,5,2,2,2,2,1],[0,0,7,7,0,0,0,1],[2,2,7,0,0,0,0,1],[0,0,7,0,0,0,0,1],[0,0,7,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,1,1],[0,7,0,0,7,0,1,1],[0,7,0,0,7,0,0,1]],"leftType":"open","rightType":"open","topType":"open","bottomType":"blocked","tags":[]},{"data":[[1,0,1,0,0,0,0,0],[1,0,1,0,0,0,0,0],[1,0,1,0,0,0,1,0],[1,0,5,2,5,2,1,0],[1,0,0,0,1,0,0,0],[1,0,0,0,5,2,2,2],[1,0,0,0,1,0,0,0],[1,0,0,0,1,0,0,0],[1,0,5,2,5,2,1,0],[1,0,1,0,0,0,1,0],[1,0,1,0,0,0,0,0],[1,0,1,0,0,0,0,0]],"leftType":"open","rightType":"open","topType":"blocked","bottomType":"open","tags":[]},{"data":[[0,0,0,0,1,1,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0],[0,0,1,0,0,0,1,0],[0,0,1,0,0,0,1,0],[2,2,1,0,0,0,5,2],[0,0,6,0,0,0,6,0],[0,0,5,2,2,2,1,0],[0,0,1,0,0,0,1,0],[0,0,1,0,0,0,1,0],[0,0,1,0,0,0,1,0],[1,1,1,1,1,1,1,1]],"leftType":"open","rightType":"blocked","topType":"open","bottomType":"open","tags":[]},{"data":[[1,1,1,1,1,1,1,1],[1,1,0,0,1,1,1,0],[0,0,0,0,0,0,1,0],[0,0,1,0,1,0,1,0],[0,0,1,0,1,0,1,0],[2,2,1,0,1,0,5,2],[0,0,0,0,0,0,0,0],[0,0,7,7,0,0,0,0],[0,0,7,7,7,7,7,7],[0,0,6,0,0,0,0,0],[0,0,6,0,0,0,0,0],[0,0,1,1,0,0,0,0]],"leftType":"blocked","rightType":"open","topType":"open","bottomType":"open","tags":[]},{"data":[[1,1,1,1,1,1,1,1],[0,6,1,0,0,0,1,1],[0,6,1,0,1,0,1,1],[0,1,1,0,1,0,0,1],[0,1,1,0,0,0,0,1],[2,2,5,2,2,2,1,1],[0,0,0,0,0,0,1,1],[0,0,1,0,1,0,0,1],[0,0,1,0,1,0,0,1],[0,0,0,0,0,0,1,1],[0,1,0,1,0,0,1,1],[0,1,0,1,0,0,1,1]],"leftType":"blocked","rightType":"open","topType":"open","bottomType":"blocked","tags":[]},{"data":[[0,1,0,0,0,0,0,0],[0,5,2,7,0,0,0,0],[0,6,0,7,0,0,0,1],[0,6,0,5,2,7,0,1],[0,6,0,6,0,7,0,1],[2,5,2,2,2,7,0,5],[0,0,0,0,0,7,0,0],[0,0,0,0,0,7,0,0],[0,7,0,5,2,6,0,0],[0,7,0,6,0,6,0,0],[0,7,0,5,2,6,0,0],[0,0,0,6,0,6,0,0]],"leftType":"open","rightType":"open","topType":"open","bottomType":"open","tags":[]},{"data":[[1,1,0,5,2,2,2,1],[1,1,0,6,0,0,1,1],[1,0,0,6,0,0,1,0],[1,0,0,6,1,1,1,0],[1,0,1,1,1,0,0,0],[1,0,1,1,2,5,2,2],[1,0,1,0,0,1,0,0],[1,0,1,0,0,1,0,1],[1,0,1,0,0,1,0,1],[1,0,5,2,2,1,0,1],[1,1,1,0,0,1,0,0],[1,1,1,0,0,1,0,0]],"leftType":"open","rightType":"open","topType":"blocked","bottomType":"open","tags":[]},{"data":[[7,7,0,0,1,0,1,1],[7,7,0,0,1,0,0,1],[0,7,0,0,1,0,0,1],[0,7,0,0,5,2,1,1],[0,7,0,0,6,0,1,0],[2,7,7,0,6,0,5,2],[0,7,7,0,1,0,0,0],[0,0,7,0,1,0,0,0],[0,0,7,0,1,0,0,0],[0,7,7,0,0,0,1,0],[0,5,2,2,2,2,1,1],[1,1,1,1,1,1,1,1]],"leftType":"open","rightType":"blocked","topType":"open","bottomType":"open","tags":[]},{"data":[[1,1,0,0,0,0,1,1],[1,0,0,0,0,0,1,1],[1,0,2,5,2,2,1,1],[7,7,0,7,0,0,6,0],[7,0,0,7,0,0,6,0],[7,0,3,7,0,2,5,2],[7,7,0,7,0,0,1,0],[1,0,0,0,0,0,1,0],[1,0,0,0,0,0,1,0],[1,1,0,0,1,0,1,0],[1,1,0,0,1,0,1,1],[1,1,0,0,1,0,1,1]],"leftType":"open","rightType":"open","topType":"open","bottomType":"open","tags":["start-door"]},{"data":[[1,1,1,0,0,0,0,1],[1,1,1,0,0,0,0,1],[1,1,1,0,0,0,0,1],[1,1,1,0,0,1,0,0],[0,0,0,0,0,1,0,0],[2,2,2,1,0,1,0,4],[0,0,0,0,0,1,0,0],[0,0,0,0,0,1,0,0],[1,0,0,1,0,1,0,0],[1,0,0,1,0,0,0,1],[1,0,0,5,2,2,2,1],[1,1,1,0,0,0,0,1]],"leftType":"open","rightType":"open","topType":"open","bottomType":"blocked","tags":["end-door"]}]}');

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Entity": () => (/* binding */ Entity)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var Entity = /** @class */ (function () {
    function Entity(pos) {
        this.x = pos.x;
        this.y = pos.y;
        this.width = 0.55;
        this.height = 0.75;
        this.speedx = 0;
        this.speedy = 0;
        this.isOnGround = false;
        this.couldUseLadder = false;
        this.isUsingLadder = false;
        // this.couldHang = false
        this.isHanging = false;
        this.jumpedSinceFrames = 0;
        this.jumpNeedsReset = false;
        this.couldCrouchDown = false;
        this.couldSideFromLadder = false;
    }
    Entity.prototype.draw = function (ctx, camera) {
        ctx.fillStyle = '#b38333';
        if (this.isOnGround) {
            ctx.fillStyle = '#886427';
        }
        if (this.isHanging) {
            ctx.fillStyle = '#275388';
        }
        if (this.isUsingLadder) {
            ctx.fillStyle = '#226638';
        }
        ctx.fillRect(camera.gameToScreenX(this.x), camera.gameToScreenY(this.y), 
        // this.x * tileSize,
        // this.y * tileSize,
        _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * this.width, _common__WEBPACK_IMPORTED_MODULE_0__.tileSize * this.height);
    };
    Entity.prototype.getSearchHash = function () {
        // return Math.random().toString()
        // return `
        // ${Math.floor(this.x / 0.7)}|
        // ${Math.floor(this.y / 0.012)}|
        // `
        // For step 1:
        // return `
        // ${(this.x)}|
        // ${(this.y)}|
        // ${this.isUsingLadder}|
        // ${this.isHanging}|
        // `
        return "\n    ".concat(Math.floor(this.x * 12), "|\n    ").concat(Math.floor(this.y * 12), "|\n    ").concat(Math.floor(this.speedy * 100), "|\n    ").concat(this.isUsingLadder, "|\n    ").concat(this.isHanging, "|\n    ");
        // ${this.isUsingLadder}`
        // For step 4:
        return "\n    ".concat(Math.floor(this.x * 4), "|\n    ").concat(Math.floor(this.y * 4), "|\n    ").concat(Math.floor(this.speedy * 5), "|\n    ").concat(this.isUsingLadder, "|\n    ").concat(this.couldUseLadder, "|\n    ").concat(this.isUsingLadder);
    };
    Entity.prototype.updateFromControls = function (controls) {
        if (!this.couldUseLadder && this.isUsingLadder) {
            this.isUsingLadder = false;
        }
        // Left and right
        // const couldSideFromLadder = (
        //   this.isUsingLadder &&
        // )
        if (controls.left && (!this.isUsingLadder || this.couldSideFromLadder)) {
            this.speedx = -0.13;
            this.isUsingLadder = false;
        }
        else if (controls.right && (!this.isUsingLadder || this.couldSideFromLadder)) {
            this.speedx = 0.13;
            this.isUsingLadder = false;
        }
        else {
            this.speedx = 0;
        }
        if (!controls.jump) {
            this.jumpNeedsReset = false;
        }
        // Juping
        if (controls.jump &&
            (this.isHanging ||
                this.isOnGround ||
                this.isUsingLadder ||
                this.jumpedSinceFrames === 8 ||
                (controls.down && this.couldCrouchDown)) &&
            (!this.jumpNeedsReset || this.jumpedSinceFrames === 8)) {
            this.jumpNeedsReset = true;
            this.speedy = controls.down ? 0 : -0.13;
            if (controls.down && this.couldCrouchDown) {
                this.y += 0.06;
            }
            this.isUsingLadder = false;
            this.isHanging = false;
            if (this.isOnGround || this.isUsingLadder || this.isHanging) {
                this.jumpedSinceFrames = 0;
            }
        }
        // Laddering
        if (this.isUsingLadder) {
            this.speedy = 0;
        }
        if (controls.up && this.couldUseLadder && !this.isHanging) {
            this.isUsingLadder = true;
            this.speedy = -0.07;
            this.speedx = 0;
            this.x = Math.floor(this.x + this.width / 2) + (1 - this.width) / 2;
        }
        if (controls.down && (this.couldUseLadder || this.isUsingLadder) && !this.isHanging) {
            this.isUsingLadder = true;
            this.speedy = 0.07;
            this.speedx = 0;
            this.x = Math.floor(this.x + this.width / 2) + (1 - this.width) / 2;
        }
        if (controls.up && this.isUsingLadder && !this.couldUseLadder) {
            this.speedy = 0;
        }
    };
    Entity.prototype.getCenter = function () {
        return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
    };
    Entity.prototype.updateFromKeyboard = function (keyboardHandler) {
        this.updateFromControls({
            left: keyboardHandler.pressed('a'),
            right: keyboardHandler.pressed('d'),
            down: keyboardHandler.pressed('s'),
            up: keyboardHandler.pressed('w'),
            jump: keyboardHandler.pressed(' '),
        });
    };
    Entity.prototype.innerUpdate = function (map, sm) {
        var eps = 0.05;
        if (!this.isUsingLadder) {
            // this.speedy = Math.min(this.speedy + 0.01, eps - 0.001)
            this.speedy = this.speedy + 0.01 * sm;
        }
        if (this.isHanging) {
            this.speedx = 0;
            this.speedy = 0;
        }
        this.y += this.speedy * sm;
        this.x += this.speedx * sm;
        var center = this.getCenter();
        var ladderTile = map.at(center.x, this.y + this.height - eps);
        this.couldUseLadder = ladderTile === 2 || ladderTile === 5;
        var wallsOnLeft = (map.blockedAt(this.x, this.y + eps) ||
            map.blockedAt(this.x, this.y + this.height - eps));
        var wallsOnRight = (map.blockedAt(this.x + this.width, this.y + eps) ||
            map.blockedAt(this.x + this.width, this.y + this.height - eps));
        // Hanging
        if (this.speedy > 0 && map.at(center.x, center.y + this.height) !== 1) {
            var lowEnoughForHanging = this.y - Math.floor(this.y) > 0.85;
            if (lowEnoughForHanging &&
                this.speedx < 0 &&
                wallsOnLeft &&
                !map.blockedAt(this.x, this.y)) {
                this.isHanging = true;
                this.y = Math.floor(this.y - eps) + 1;
            }
            // Right
            if (lowEnoughForHanging &&
                this.speedx > 0 &&
                wallsOnRight &&
                !map.blockedAt(this.x + this.width + eps, this.y)) {
                this.isHanging = true;
                this.y = Math.floor(this.y - eps) + 1;
            }
        }
        // Ceiling
        if (this.speedy < 0 &&
            (map.blockedAt(this.x + eps, this.y) ||
                map.blockedAt(this.x + this.width - eps, this.y))) {
            this.y = Math.floor(this.y) + 1;
            this.speedy = 0;
        }
        // Floor
        this.isOnGround = false;
        if (this.speedy > 0 &&
            (map.blockedAt(this.x + eps, this.y + this.height) ||
                map.blockedAt(this.x + this.width - eps, this.y + this.height) ||
                ((map.at(this.x + eps, this.y + this.height) === 5 ||
                    map.at(this.x + this.width - eps, this.y + this.height) === 5 ||
                    map.at(this.x + eps, this.y + this.height) === 6 ||
                    map.at(this.x + this.width - eps, this.y + this.height) === 6) && ((this.y + this.height) - Math.floor((this.y + this.height)) < 0.05)))) {
            if (!this.isUsingLadder || map.at(center.x, this.y + this.height + eps) === 1) {
                this.speedy = 0;
                this.y = Math.floor(this.y + this.height) - this.height;
                this.isOnGround = true;
            }
        }
        this.couldCrouchDown = (this.isOnGround &&
            ((map.at(this.x + eps, this.y + this.height + eps) === 5 ||
                map.at(this.x + eps, this.y + this.height + eps) === 6) &&
                (map.at(this.x + this.width - eps, this.y + this.height) === 5 ||
                    map.at(this.x + this.width - eps, this.y + this.height) === 6)) ||
            ((map.at(this.x + eps, this.y + this.height + eps) === 0) &&
                (map.at(this.x + this.width - eps, this.y + this.height) === 5 ||
                    map.at(this.x + this.width - eps, this.y + this.height) === 6)) ||
            ((map.at(this.x + eps, this.y + this.height + eps) === 5 ||
                map.at(this.x + eps, this.y + this.height + eps) === 6) &&
                (map.at(this.x + this.width - eps, this.y + this.height) === 0)));
        // // Was on floor and should still be able to jump
        // if (
        //   (
        //     this.speedx > 0 &&
        //     map.at(this.x + eps, this.y + this.height) !== 1 &&
        //     map.at(this.x + eps - 0.2, this.y + this.height) === 1 &&
        //     map.at(this.x + eps - 0.2, this.y + this.height - 0.2) !== 1
        //   )
        // ) {
        //   this.isOnGround = true
        // }
        // Walls left
        if (wallsOnLeft) {
            this.x = Math.floor(this.x) + 1;
        }
        // Walls right
        if (wallsOnRight) {
            this.x = Math.floor(this.x + this.width) - this.width;
        }
        // Going side from bottom of ladders
        if (this.isUsingLadder &&
            (this.y + this.height - eps) - Math.floor(this.y + this.height - eps) > 0.5 &&
            (map.blockedAt(center.x, Math.floor(this.y + this.height - eps + 0.5)) ||
                map.at(center.x, Math.floor(this.y + this.height - eps + 0.5)) === 5 ||
                map.at(center.x, Math.floor(this.y + this.height - eps + 0.5)) === 6)) {
            this.couldSideFromLadder = true;
        }
        else {
            this.couldSideFromLadder = false;
        }
    };
    Entity.prototype.update = function (map) {
        this.jumpedSinceFrames += 1;
        var steps = 10;
        for (var i = 0; i < steps; i++) {
            this.innerUpdate(map, 1 / steps);
        }
        // const storeRes = 8
        // this.x = Math.floor(this.x * storeRes) / storeRes
        // this.y = Math.floor(this.y * storeRes) / storeRes
    };
    Entity.prototype.clone = function () {
        var clone = __assign({}, this);
        Object.setPrototypeOf(clone, Entity.prototype);
        return clone;
    };
    return Entity;
}());



/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SearchPointScoreMap": () => (/* binding */ SearchPointScoreMap),
/* harmony export */   "getPointScore": () => (/* binding */ getPointScore)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

var getPointScore = function (pointt, pointScores) {
    var point = { x: pointt.x - 0.5, y: pointt.y - 0.5 };
    var x1 = Math.floor(pointt.x - 0.5);
    var x2 = Math.floor(pointt.x + 0.5);
    var y1 = Math.floor(pointt.y - 0.5);
    var y2 = Math.floor(pointt.y + 0.5);
    var q11 = pointScores.get(x1, y1);
    var q12 = pointScores.get(x1, y2);
    var q21 = pointScores.get(x2, y1);
    var q22 = pointScores.get(x2, y2);
    // Bilinear https://en.wikipedia.org/wiki/Bilinear_interpolation
    if (q11 && q12 && q21 && q22) {
        var w11 = (x2 - point.x) * (y2 - point.y) / (x2 - x1) * (y2 - y1);
        var w12 = (x2 - point.x) * (point.y - y1) / (x2 - x1) * (y2 - y1);
        var w21 = (point.x - x1) * (y2 - point.y) / (x2 - x1) * (y2 - y1);
        var w22 = (point.x - x1) * (point.y - y1) / (x2 - x1) * (y2 - y1);
        return (q11 * w11 +
            q12 * w12 +
            q21 * w21 +
            q22 * w22);
    }
    var remainingPoints = [
        { score: q11, point: { x: x1, y: y1 } },
        { score: q12, point: { x: x1, y: y2 } },
        { score: q21, point: { x: x2, y: y1 } },
        { score: q22, point: { x: x2, y: y2 } },
    ].filter(function (t) { return t.score !== undefined; });
    var defaultValue = pointScores.get(Math.floor(point.x), Math.floor(point.y)) || 9999;
    // Three points https://math.stackexchange.com/questions/1099390/billinear-interpolation-of-3-points
    if (remainingPoints.length === 3) {
        var s1 = remainingPoints[0].score;
        var p1 = remainingPoints[0].point;
        var s2 = remainingPoints[1].score;
        var p2 = remainingPoints[1].point;
        var s3 = remainingPoints[2].score;
        var p3 = remainingPoints[2].point;
        var divider = ((p2.y - p3.y) * (p1.x - p3.x) +
            (p3.x - p2.x) * (p1.y - p3.y));
        var w1 = ((p2.y - p3.y) * (point.x - p3.x) +
            (p3.x - p2.x) * (point.y - p3.y)) / divider;
        var w2 = ((p3.y - p1.y) * (point.x - p3.x) +
            (p1.x - p3.x) * (point.y - p3.y)) / divider;
        var w3 = 1 - w1 - w2;
        return s1 * w1 + s2 * w2 + s3 * w3;
        // if (
        //   p2.x * (p1.y - p2.y) +
        //   p1.x * (p2.y - p3.y) +
        //   p2.x * (p3.y - p1.y) === 0
        // ) {
        //   [s1, p1, s2, p2] = [s2, p2, s1, p1]
        //   if (
        //     p2.x * (p1.y - p2.y) +
        //     p1.x * (p2.y - p3.y) +
        //     p2.x * (p3.y - p1.y) === 0
        //   ) {
        //     [s1, p1, s3, p3] = [s3, p3, s1, p1]
        //   }
        // }
        //
        // const divider = (
        //   p3.x * (p1.y - p2.y) +
        //   p1.x * (p2.y - p3.y) +
        //   p2.x * (p3.y - p1.y)
        // )
        //
        // const a = (
        //   s3 * (p1.y - p2.y) +
        //   s1 * (p2.y - p3.y) +
        //   s2 * (p3.y - p1.y)
        // ) / divider
        // const b = (
        //   s3 * (p2.x - p1.x) +
        //   s2 * (p1.x - p3.x) +
        //   s1 * (p3.x - p2.x)
        // ) / divider
        // const c = (
        //   s3 * (p1.x * p2.y - p2.x * -p1.y) +
        //   s2 * (p3.x * p1.y - p1.x * -p3.y) +
        //   s1 * (p2.x * p3.y - p3.x * -p2.y)
        // ) / divider
        //
        // if (a === Infinity || a === -Infinity) {
        //   // console.log(p1, p2, p3, s1, s2, s3)
        //   debugger;
        //   // console.log(a, c)
        // }
        //
        // const val = a * point.x + b * point.y + c
        //
        // // debugger;
        // console.log(s1, p1, s2, p2, s3, p3, a, b, c, val)
        // console.log(a, b, c)
        // console.log(val)
        //
        // return val
        //
        // // return 10
        // // return defaultValue
        // // return pointScores.get(Math.floor(point.x), Math.floor(point.y)) || 9999
    }
    // Two points
    if (remainingPoints.length === 2) {
        var s1 = remainingPoints[0].score;
        var p1 = remainingPoints[0].point;
        var s2 = remainingPoints[1].score;
        var p2 = remainingPoints[1].point;
        if (p1.x === p2.x) {
            var ratio_1 = (p1.y - point.y) / (p1.y - p2.y);
            return s2 * ratio_1 + s1 * (1 - ratio_1);
        }
        if (p1.y === p2.y) {
            var ratio_2 = (p1.x - point.x) / (p1.x - p2.x);
            return s2 * ratio_2 + s1 * (1 - ratio_2);
        }
        var k = (p2.y - p1.y) / (p2.x - p1.x);
        var a = p2.y - k * p2.x;
        var b = point.y + 1 / k * point.x;
        var nx = (b - a) / (k + 1 / k);
        var ratio = (p2.x - nx) / (p2.x - p1.x);
        var retVal = s1 * ratio + s2 * (1 - ratio);
        return retVal;
    }
    return 10;
    // return defaultValue
};
var SearchPointScoreMap = /** @class */ (function () {
    function SearchPointScoreMap(gameMap) {
        this.height = gameMap.height;
        this.width = gameMap.width;
        this.data = (0,_common__WEBPACK_IMPORTED_MODULE_0__.range)(this.width * this.height).map(function (n) { return -1; });
    }
    SearchPointScoreMap.prototype.reset = function () {
        for (var i = 0; i < this.data.length; i++) {
            this.data[i] = -1;
        }
    };
    SearchPointScoreMap.prototype.has = function (x, y) {
        return this.get(x, y) !== undefined;
    };
    SearchPointScoreMap.prototype.get = function (x, y) {
        if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
            return undefined;
        }
        if (this.data[x * this.height + y] === -1) {
            return undefined;
        }
        return this.data[x * this.height + y];
    };
    SearchPointScoreMap.prototype.set = function (x, y, value) {
        this.data[x * this.height + y] = value;
    };
    return SearchPointScoreMap;
}());



/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Camera": () => (/* binding */ Camera)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

var Camera = /** @class */ (function () {
    function Camera(canvasWidth, canvasHeight) {
        this.centerX = 0;
        this.centerY = 0;
        this.canvasWidth = canvasWidth;
        this.canvasHeight = canvasHeight;
    }
    Camera.prototype.getDrawBoundaries = function () {
        return {
            topLeftX: Math.floor((this.centerX - this.canvasWidth / 2 / _common__WEBPACK_IMPORTED_MODULE_0__.tileSize) + 0),
            topLeftY: Math.floor((this.centerY - this.canvasHeight / 2 / _common__WEBPACK_IMPORTED_MODULE_0__.tileSize) + 0),
            bottomRightX: Math.floor((this.centerX + this.canvasWidth / 2 / _common__WEBPACK_IMPORTED_MODULE_0__.tileSize) + 1),
            bottomRightY: Math.floor((this.centerY + this.canvasHeight / 2 / _common__WEBPACK_IMPORTED_MODULE_0__.tileSize) + 1),
        };
    };
    Camera.prototype.moveTowards = function (x, y) {
        this.centerX -= (this.centerX - x) * 0.5;
        this.centerY -= (this.centerY - y) * 0.5;
    };
    Camera.prototype.gameToScreenX = function (x) {
        return Math.floor((x - this.centerX) * _common__WEBPACK_IMPORTED_MODULE_0__.tileSize + this.canvasWidth / 2);
    };
    Camera.prototype.gameToScreenY = function (y) {
        return Math.floor((y - this.centerY) * _common__WEBPACK_IMPORTED_MODULE_0__.tileSize + this.canvasHeight / 2);
    };
    return Camera;
}());



/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "worker": () => (/* binding */ worker)
/* harmony export */ });
var url = new URL(/* asset import */ __webpack_require__(11), __webpack_require__.b);
console.log('url', url);
var worker = new Worker(url);


/***/ }),
/* 11 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "asset-ignore-me";

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			0: 1
/******/ 		};
/******/ 		
/******/ 		// no chunk install function needed
/******/ 		// no chunk loading
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _src_game_GameMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _src_game_SearchPointScoreMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/* harmony import */ var _src_game_Entity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);




var ctx = self;
console.log('asdf');
var game = undefined;
// Respond to message from parent thread
ctx.addEventListener('message', function (event) {
    console.log('worker: got message', event.data);
    if (event.data.type === 'set-game') {
        console.log('worker: set-game event');
        // game = Object.setPrototypeOf(event.data.data, Game.prototype)
        game = Object.assign(event.data.payload.game, _src_game_Game__WEBPACK_IMPORTED_MODULE_0__.Game.prototype);
        if (game) {
            game.map = Object.assign(game.map, _src_game_GameMap__WEBPACK_IMPORTED_MODULE_1__.GameMap.prototype);
            game.debugSearchPointScores = Object.assign(game.debugSearchPointScores, _src_game_SearchPointScoreMap__WEBPACK_IMPORTED_MODULE_2__.SearchPointScoreMap.prototype);
        }
        console.log('worker: set game', game);
    }
    if (event.data.type === 'route-search') {
        console.log('worker: route-search event');
        if (!game) {
            console.log('worker: game not set');
            return;
        }
        var startTime = performance.now();
        var _a = game.routeSearch(Object.assign(event.data.payload.entity, _src_game_Entity__WEBPACK_IMPORTED_MODULE_3__.Entity.prototype), event.data.payload.x, event.data.payload.y, 5000), path = _a.path, debugPoints = _a.debugPoints;
        var searchTime = performance.now() - startTime;
        console.log('search took', searchTime / 1000, 's, used', debugPoints.length, 'points');
        ctx.postMessage({
            type: 'route-search-result',
            payload: {
                path: path,
            }
        });
    }
});

})();

/******/ })()
;